



# shell介绍

> 1. shell是什么
>
>    ```shell
>    shell是命令，类似于windows的dos命令
>    shell也是一门程序设计语言，里面含有变量，函数，逻辑控制语句等
>    ```
>
>    
>
> 2. shell脚本是什么
>
>    ```shell
>    是一个文本文件，里面可以编写shell命令或者进行编程，形成一个可重用执行的脚本文件
>    ```
>
>    
>
> 3. shell脚本的作用
>
>    ```shell
>    通过shell编程提高对Linux系统管理工作效率	
>    ```
>
>    
>
> 4. Linux系统默认的shell解析器
>
>    ```shell
>    /bin/bash
>    ```
>
>    

# 脚本文件的常用三种执行方式

> 1. sh解析器执行方式
>
>    语法：`sh  脚本文件`
>
> 2. bash解析器执行方式
>
>    语法：`bash  脚本文件`
>
> 3. 仅路径方式
>
>    语法：`脚本文件路径`
>
>    脚本文件自己执行需要有执行权限，否则无法执行
>
> 三种方式的区别：
>
> ​	sh或bash执行脚本文件方式是直接使用shell解释器运行脚本文件，不需要脚本有可执行权限
>
> ​	仅路径方式是执行脚本自己，需要执行权限

# shell变量

变量类型：

​	1. 系统环境变量

​	2. 自定义变量

​	3. 特殊符号变量

## 系统环境变量

#### 介绍

```shell
是系统提供的共享变量，是Linux系统加载shell的配置文件中定义的变量，共享给所有的shell程序使用
```



#### shell配置文件分类

> 1. 全局配置文件
>
>    /etc/profile
>
>    /etc/profile.d/*.sh
>
>    /etc/bashrc
>
> 2. 个人配置文件
>
>    ~/.bash_pofile
>
>    ~/.bashrc
>
> 一般情况下，都是直接针对全局变量配置进行操作

#### 环境变量分类

> 在Linux系统中，环境变量按照其作用范围不同大致可以分为`系统级环境变量`和`用户级环境变量`
>
> 系统级环境变量：shell环境加载全局配置文件中的变量共享给所有用户的shell程序使用
>
> 用户级环境变量：shell环境加载个人配置文件中的变量共享给当前用户的shell程序使用

查看当前shell系统环境变量

`env`

查看shell变量（系统环境变量+自定义变量+函数）

`set`

#### 常用系统环境变量

| 变量名称   | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| `PATH`     | 与Windows环境变量PATH功能一样，设置命令的搜索路径，以冒号为分割 |
| HOME       | 当前用户主目录：/root                                        |
| SHELL      | 当前shell解析器类型：/bin/bash                               |
| `HISTFILE` | 显示当前用户执行命令的历史列表文件：/root/.bash_history      |
| PWD        | 显示当前所在路径                                             |
| OLDPWD     | 显示之前的路径                                               |
| HOSTNAME   | 显示当前主机名                                               |
| HOSTTYPE   | 显示主机的架构：是x86 还是x64等                              |
| `LANG`     | 设置当前系统语言环境：zh_CN.UTF-8                            |



## 自定义变量

### 自定义变量分类：

>  	1. 自定义局部变量：定义在一个脚本文件中的变量，只能在这个脚本文件中使用的变量，就是局部变量
>  	2. 自定义常量：
>  	3. 自定义全局变量

### 自定义局部变量

定义在一个脚本文件中的变量，只能在这个脚本文件中使用的变量，就是局部变量

#### 定义与使用

定义语法

```shell
var_name=value
```

变量定义规则

> 1. 变量名称可以有字母，数字和下划线组成，但是不能以数字开头
> 2. 等号两侧不能有空格
> 3. 在bash环境中，变量的默认类型都是字符串类型，无法直接进行数值运算
> 4. 变量的值如果有空格，必须使用双引号括起来
> 5. 不能使用shell关键字作为变量名称

查询变量值语法

```shell
语法一：直接使用变量名查询
$var_name
语法二：使用花括号
${var_name}
区别：花括号方式适合拼接字符串
```

变量删除

```shell
unset var_name
```



### 自定义常量

变量设置值以后不可以修改的变更了叫常量，也叫只读变量

语法：

```shell
readonly var_name=value
```



### 自定义全局变量

父子shell环境介绍

> ​	例如：有2个shell脚本文件A.sh和B.sh
>
> ​	如果在A.sh脚本文件中执行了B.sh脚本文件，那么A.sh就是父shell环境，B.sh就是子shell环境

自定义全局变量介绍

> ​	在当前脚本文件中定义全局变量，这个全局变量可以在当前shell环境和子shell环境中都可以使用

自定义全局变量语法

```shell
export var_name=value
```



## 特殊符号变量

### 特殊变量：$n

语法

```shell
$n
```

含义

> 用于接指定收脚本文件执行时传入的某个参数
>
> $0：用于获取当前脚本文件名称
>
> \$1~$9：代表获取第一个到第九个输入参数
>
> 获取第十个及以上输入参数则使用：${数字}

执行脚本文件传入参数语法

```shell
bash 脚本文件  参数1 参数2 参数3 ...
```



### 特殊变量：$#

语法

```shell
$#
```

含义

> 获取所有输入参数的个数



### 特殊变量：\$*、$@

语法

```shell
$*
$@
```

含义

> 都是获取所有输入的参数，用于以后输出所有参数

区别

> 1.不使用双引号括起来，功能一样
>
> 2.使用双引号括起来
>
> ​	“$*”获取的所有参数拼接为一个字符串
>
> ​	“$@”获取一组参数列表对象
>
> ​	使用循环打印所有输入参数可以看出区别

循环语法

> for var in 列表变量
>
> do   //循环开始
>
> ​	循环体
>
> done  //循环结束



### 特殊变量：$?

语法

```shell
$?
```

含义

> 用于获取上一个命令的执行后的状态码，或者是函数的返回值
>
> ​	每个命令的执行后都有一个状态码，这个状态码用于说明命令执行是否成功
>
> ​	一般来说，返回0代表命令执行成功，非0代表执行失败



### 特殊变量：$

语法

```shell
$$
```

含义

> 用于获取当前shell环境的进程id号



# shell环境变量深入：自定义系统环境变量

## 全局配置文件/etc/profile应用场景

> 当用户进入shell环境初始化的时候会加载全局配置文件/etx/profile里面的环境变量，供给所有shell程序使用
>
> 以后只要是所有shell程序使用的变量，就可以定义在这个文件中

## 创建环境变量步骤

1.编辑/etc/profile全局配置文件

```sh
定义变量并导出为环境变量
export VAR1=value
```

2.重载配置文件/etc/profile，因为配置文件修改后需要重新加载才能生效

```sh
source /etc/profile
```



# shell环境变量深入：加载流程原理介绍

## shell工作环境介绍

> 用户进入Linux系统就会初始化shell环境，这个环境会加载全局配置文件和用户个人配置文件中的环境变量。每个脚本文件都有自己的shell环境

## shell工作环境分类

### 交互式与非交互式shell

交互式shell

> 与用户进行交互。效果就是用户输入一个命令，shell环境立刻反馈响应，例如：ls  pwd

非交互式shell

> 不需要用户参与就可以执行一系列操作。比如一个脚本文件，直接执行并给出结果

### 登录shell与非登录shell

| 类型名称        | 含义                                              |
| --------------- | ------------------------------------------------- |
| shell登录环境   | 需要用户名、密码登录的shell环境                   |
| shell非登录环境 | 不需要用户名、密码登录的shell环境 或 执行脚本文件 |

识别当前shell环境是登录环境还是非登录环境

```sh
echo $0  //用于获取当前shell环境，输出bash代表非登录环境，-bash代表登录环境
    //$0在脚本中使用是代表获取脚本名字
```

切换shell环境

> 第一种：直接使用用户名和密码登录就是shell登录环境
>
> 第二种：切换用户的时候指定登录环境还是非登录环境
>
> ​	su 用户名    //切换到非登录环境
>
> ​	su -l/\--login  用户名    //切换到登录环境
>
> 第三种：bash   //切换到非登录环境
>
> ​	bash/sh -l 脚本文件     //先加载登录环境，在运行脚本文件

## 环境变量初始化流程

shell登录环境环境变量加载流程

> 第一步：执行/etc/profile文件记载系统环境变量
>
> 第二步：执行/etc/profile.d/*.sh文件加载系统环境变量   
>
> 第三步：执行当前用户下的~/.bash_profile文件加载用户环境变量  
>
> 第四步：执行当前用户下的~/.bashrc文件加载用户环境变量   
>
> 第五步：执行/etc/bashrc文件加载系统环境变量

shell非登录环境环境变量加载流程

> 首先会继承上面登录环境的环境变量
>
> 第一步：执行当前用户下的~/.bashrc文件加载用户环境变量
>
> 第二步：执行/etc/bashrc文件加载系统环境变量
>
> 第三步：执行/etc/profile.d/*.sh文件加载系统环境变量 



# shell字符串变量

字符串的3种格式

> 单引号方式
>
> ​	使用单引号任何字符都会原样输出，在其中的变量是无效的
>
> 双引号方式
>
> ​	使用双引号，如果其中包含变量，那么变量会得到解析
>
> ​	字符串中还可以出现子双引号，但是需要加上\转义
>
> 不用引号方式
>
> ​	不被引号包括的字符串中出现变量也会被解析
>
> ​	字符串中不会出现空格，空格后面的的字符串会被当做命令来执行

获取字符串的长度

```sh
${#变量名}
```



# shell字符串截取

| 格式                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ${变量名:start:length}   | 从字符串左边第start个字符开始<br>向右截取length个字符。      |
| ${变量名:start}          | 从字符串左边第start个字符开始截取所有字符                    |
| ${变量名:0-start:length} | 从字符串右边第start个字符开始，<br>向右截取length个字符。    |
| ${变量名:0-start}        | 从字符串的右边第start个字符开始截取所有字符                  |
| ${变量名#*chars}         | 从字符串左边第一次出现chars\*的位置开始<br>截取chars*右边的所有字符 |
| ${变量名##*chars}        | 从字符串左边最后一次出现chars\*的位置开始<br>截取chars*右边的所有字符 |
| ${变量名%chars*}         | 从字符串右边第一次出现chars\*的位置开始<br>截取chars*左边的所有字符 |
| ${变量名%%chars*}        | 从字符串右边最后一次出现chars\*的位置开始<br>截取chars*左边的所有字符 |



# shell数组变量

## 数组的定义

在shell中，用()来表示数组，数组元素之间用空格来分割

语法

```sh
array_name=(item1 item2 ...)    //方式一
array_name=([下标索引1]=item1 [下标索引2]=item2 ...)   //方式二
注意：赋值号`=`之间不能有空格，
```

## 数组的获取

语法

1. 通过下标获取元素值，index从0开始

   ```sh
   ${arr[index]}
   ```

2. 获取值同时复制给其他变量

   ```sh
   item=${arr[index]}
   ```

3. 使用@或*可以获取数组中的所有元素

   ```sh
   ${arr[@]}
   ${arr[*]}
   ```

4. 获取数组的长度或个数

   ```sh
   ${#arr[@]}
   ${#arr[*]}
   ```

5. 获取数组指定元素的字符长度

   ```sh
   ${#arr[索引]}
   ```

   

## 数组拼接

所谓的数组拼接，就是将两个数组连接成一个数组

语法：使用@或*获取数组所有元素之后进行拼接

```sh
array_name=(${arr1[*]} ${arr2[@]})
```



## 数组删除

语法:

删除数组指定元素数据

```sh
unset array_name[index]
```

删除整个数组

```sh
unset array_name
```



# shell内置命令

介绍

> shell内置命令，就是由Bash Shell自身提供的命令，而不是文件系统中的可执行脚本文件
>
> 使用type来查看一个命令是不是内置命令
>
> ```sh
> type 命令
> ```
>
> 内置命令比外部命令执行速度更快，执行外部命令时不但会触发磁盘I/O，还会fork(开启)一个单独的进程来执行，执行完成后再退出。而执行内置命令相当于调用当前shell进程的一个函数，还是在当前shell环境进程内，减少了上下文切换



## alias设置别名

定义语法

```shell
alias 别名="命令"
这是临时定义别名，想永久定义别名需要在配置文件中定义
```

删除语法

```shell
unalias 别名      //删除指定的别名
unalias -a       //删除当前shell环境中所有的别名
以上两种方式删除都是临时删除当前shell的别名，如果想永久删除必须去配置文件中手动删除
```



## echo输出字符串

echo输出不换行的字符串

```shell
echo -n "输出的数据"
```

echo输出转义字符(使转义字符生效)

```shell
echo -e 含有转义字符的数据
```



## read读取控制台输入

介绍

> read时shell内置命令，用于从标准输入中读取数据并复制给变量。如果没有进行重定向，默认就是从终端控制台读取用户输入的数据；如果进行了重定向，那么可以从文件中读取数据。

语法

> read \[\-options][var1 var2 ...]
>
> ​	options表示选项，如下表所示，var表示用来存储数据的变量，可以有一个，也可以有多个
>
> ​	options和var都是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量REPLY变量中。
>
> ​	$REPLY保存read最后一个读入命令的数据
>
> optinos支持的参数
>
> | 参数         | 说明                                                         |
> | ------------ | ------------------------------------------------------------ |
> | -a array     | 把读取的数据赋值给数组array，从下标0开始                     |
> | -d delimiter | 用字符串delimiter指定读取结束的位置，而不是一个换行符<br>（读取到的数据不包括delimiter） |
> | -e           | 在获取用户输入的时候，对功能键进行编码转换，不会直接显示<br>功能键对应的字符 |
> | -n num       | 读取num个字符，而不是整行字符                                |
> | -p prompt    | 显示提示信息，提示内容为prompt                               |
> | -r           | 原样读取（Raw mode），不把反斜杠字符解释为转义字符           |
> | -s           | 静默模式（Silent mode），不会再屏幕上显示输入的字符。<br>当输入密码和其他确认信息的时候，这是很有必要的 |
> | -t seconds   | 设置超时时间，单位为秒。如果用户没有再指定时间内完成输入，<br>那么read将会返回一个非0的退出状态，表示读取失败 |
> | -u fd        | 使用文件描述符fd作为输入源，而不是标准输入，类似于重定向。   |
>
> 



## declare设置变量

介绍

> declare命令用于声明shell变量。可用来声明变量并设置变量的属性，也可用来显示shell函数。若不加上任何参数，则会显示全部的shell变量与函数（与执行set命令的效果相同）

作用

> 1. declare设置变量的属性【重要】
> 2. 查看全部shell变量与函数
> 3. 实现关联数组变量

declare设置变量属性的语法

> declare \[+/-] \[aArxif][变量名称=设置值]
>
> ​	+/- ：“-”可用来指定变量的属性，“+”则是取消变量所设的属性
>
> ​	a ：array，设置为普通索引数组
>
> ​	A ：Array，设置为key-value关联数组
>
> ​	r ：readonly，将变量设置为只读，也可以使用readonly
>
> ​	x ：export，设置变量为全局变量，也可以使用export
>
> ​	i ：int，设置为整型变量
>
> ​	f ：function，设置为一个函数变量

实现key-value关联数组变量语法

关联数组也称为“键值对”数组，键就是字符串形式的数组下标，值就是元素值

```shell
declare -A 关联数组变量名=([字符串key1]=值1 [字符串key2]=值2 ...)
```

获取只送key的值

```shel
${关联数组变量名[key]
```

获取所有值

```shell
${关联数组变量名[@]}
${关联数组变量名[*]}
```



# shell运算符：算术运算符

expr语法

```shell
expr 算术运算符表达式     //直接运算
result=`expr 算术运算符表达式`   //将运算结果赋值给result，注意需要加反引号
```



# shell运算符：比较运算符

## 整数比较运算符

> 英文方式比较：[ $a -eq \$b ]
>
> 运算符方式比较：(($a==\$b))
>
> 每次比较都会有一个返回值1或者0；返回0代表成功，返回1代表失败



## 字符串比较运算符

字符串比较可以使用`[[]]`和`[]`两种方式

> -z：检测字符串长度是否为0，如果为0则返回0，否正返回1    [ -z “ ” ]
>
> -n：检测字符串长度是否不为0，如果不为0则返回0，否正返回1  [ -n “ ” ]
>
> \$：检测字符串是否不为空，不为空返回0，为空返回1    [ $“ ” ]
>
> 字符串没有`<=` ，可以通过`[[ "a" < "b" || "a" == "b" ]]`



## []与[[]]的区别

区别一：word splitting(单词分割)的发生

> word splitting(单词分割)：会将含有空格的字符串进行拆分分割后再比较
>
> []会有单词分割发生
>
> [[]]不会有单词分割发生【推荐使用】

区别二：转义字符

> []对`<`需要转义，格式为[ 字符串1 \\< 字符串2 ]
>
> [[]]对`<`不需要转义，格式为[[ 字符串1 < 字符串2 ]]



# shell运算符：布尔运算符

| 运算符 | 说明                     | 举例                   |
| ------ | ------------------------ | ---------------------- |
| !      | 取反                     | [ ! 表达式 ]           |
| -o     | or运算，有一个成立就成立 | [ 表达式1 -o 表达式2 ] |
| -a     | 与运算，两个都成立才成立 | [ 表达式1 -a 表达式2 ] |

【注意】：布尔运算符放在[]或与test命令配合使用才有效；布尔运算符常与test命令配合使用



# shell运算符：逻辑运算符

| 运算符 | 说明                     | 举例                     |
| ------ | ------------------------ | ------------------------ |
| &&     | 与运算，两个都成立才成立 | [ 表达式1 && 表达式2 ]   |
| \|\|   | 或运算，有一个成立就成立 | [ 表达式1 \|\| 表达式2 ] |
| ！     | 取反                     | [ ! 表达式 ]             |

【注意】：使用`&&`和`||`的运算必须放在`[[]]`或`(())`中才有效，否正报错。

​	 `!` 可以用在`[]`和`[[]]`中，不可以再(())

# 逻辑运算符与布尔运算符的区别

布尔运算符：`! -o -a`

​	必须有[]或test命令执行

逻辑运算符：`!  ||  &&`

​	 `|| &&`必须有[[]]或(())执行

​	 `!`可以用在[]或[[]]，不可以用在(())



# shell运算符：文件测试运算符

| 运算符          | 说明                                                         | 举例                  |
| --------------- | ------------------------------------------------------------ | --------------------- |
| -d file         | 检测文件是否为目录，如果是，返回0                            | [[ -d $file ]]        |
| -f file         | 检测文件是否是普通文件，如果是，返回0                        | [[ -f $file ]]        |
| -r file         | 检测文件是否可读，如果是，返回0                              | [[ -r $file ]]        |
| -w file         | 检测文件是否可写，如果是，返回0                              | [[ -w $file ]]        |
| -x file         | 检测文件是否可执行，如果是，返回0                            | [[ -x $file ]]        |
| -e file         | 检测文件大小是否为空（文件大小是否大于0），<br>不为空返回0。用于检测文件是否存在 | [[ -e $file ]]        |
| file1 -nt file2 | 检测file1是否比file2新                                       | [[ file1 -nt file2 ]] |



# shell计算命令：expr命令详解

## 字符串语法

计算字符串长度语法

> expr length 字符串
>
> 例如：expr length “itheima”  返回7

截取字符串语法

> expr substr 字符串 start end
>
> //start截取字符串的开始位置，从1开始
>
> //end截取字符串的结束位置，包含这个位置
>
> 例如： expr substr “itheima” 1 2   返回：it

获取某个字符再字符串中第一次出现的位置语法

> expr index 被查找的字符串  需要查找的字符
>
> 例如：expr index “itheima” t    返回：2

正则表达式语法1

> expr match 字符串 正则表达式
>
> //正则表达式默认带有^，代表以什么开头
>
> //返回值为符合匹配字符的长度，否正返回0
>
> 例如：expr match “itheima” “.*m”    返回：6
>
> //正则表达式通配符`.`代表任意一个字符
>
> //正则表达式通配符`*`代表前面的字符可以出现任意次
>
> //`.*m`含义为匹配字符串中m前面的包括m再内的字符串长度

正则表达式语法2（功能与语法1相同）

> expr 字符串 : 正则表达式
>
> 例如：expr match “itheima” “.*m”    返回：6



# shell计算命令：(())详解

用法

| 运算命令               | 说明                                          |
| ---------------------- | --------------------------------------------- |
| ((a=1+2))  ((b=a+1))   | 在计算后直接赋值，(())会自动解析变量          |
| a=\$((1+2)) b=$((a+1)) | 可以在(())前面加上$符号获取(())命令的执行结果 |
| ((a>7 && b==c))        | (())也可以进行逻辑运算                        |
| ((a=3+5, b=a+1))       | 对多个表达式同时进行计算并赋值                |



# shell计算命令：let命令详解

介绍

> let命令和双小括号(())在数字计算方面功能一样，但是没有(())功能强大，let只能用于赋值计算，不能直接输出，不可以和条件判断一起使用。let是最简洁的整数运算赋值命令

语法

```shell
let 赋值表达式   
例如：let a=1+1 b=a+1 c=a+b
```



# shell计算命令：$[]详解

介绍

> 和(())、let命令类似，$[]也只能进行整数运算。但是只能对单个表达式的计算求值与输出

语法

```shell
$[表达式]
//$[]会对表达式进行计算，并取得计算结果
//表达式内部不可以赋值给变量
```



# shell计算命令：bc命令详解

介绍

> bc命令可以很方便的进行浮点运算，bc命令是Linux简单的计算器，能进行进制转换与计算

语法

```shell
bc [options] [参数]
```

options

| 选项 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -h   | 显示帮助信息                                                 |
| -v   | 显示命令版本信息                                             |
| -i   | 强制交互                                                     |
| -w   | 显示POSIX的警告信息                                          |
| -s   | 使用POSIX标准来处理                                          |
| `-q` | 不显示欢迎信息。默认使用bc命令回车会有很多欢迎信息，可以使用`bc -q`就不会有欢迎信息 |
| `-l` | 使用标准数学库，例如使用内置函数就需要使用这个参数           |

参数

> 可以指定包含计算任务的文件

内置变量

| 变量名    | 作用                                          |
| --------- | --------------------------------------------- |
| scale     | 指定精度，指定小数点后保留几位，默认为0不保留 |
| ibase     | 指定输入数字的进制，默认为十进制              |
| obase     | 指定输出数字的进制，默认为十进制              |
| last或者. | 获取最近计算打印结果的数字                    |

内置数学函数（使用内置函数必须使用`bc -l`选项）

| 函数名 | 作用                        |
| ------ | --------------------------- |
| s(x)   | 计算x的正弦值，x是弧度值    |
| c(x)   | 计算x的余弦值，x是弧度值    |
| a(x)   | 计算x的反正切值，返回弧度值 |
| l(x)   | 计算x的自然对数             |
| e(x)   | 求e得x次方                  |
| j(n,x) | 计算从n到x得阶数            |



## 非互动是管道运算

语法

```shell
echo "表达式" |bc [options]    //表达式里可以引用shell变量
```

将bc计算结果赋值给shell变量

```shell
var_name=`echo "表达式" |bc [options]`    //方式一
var_name=$(echo "表达式" |bc [options])    //方式二
区别：``是所有linux支持的方式，兼容性好，但是容易和引号产生混淆
	$()不是所有Linux都支持的方式，兼容性较差，但是不容易产生混淆
```



## 非互动式的输入重定向运算

语法

```shell
var_name=`bc [options] << EOF    //方式一
>  第一个表达式
>  第二个表达式
>  ...
>  EOF
>  `

var_name=$(bc [options] << EOF    //方式二
>  第一个表达式
>  第二个表达式
>  ...
>  EOF
> )
含义：将EOF中间的多行表达式输入给bc去执行，将bc执行的结果给到变量var_name
```



# 流程控制语句：if else

### if 语法

多行语法

```shell
if 条件
then
	命令
fi
```

单行语法

```shell
if 条件； then 命令；fi
```



### if else语法

```shell
if 条件
then
	命令
else
	命令
fi
```



### if elif else语法

```shell
if 条件1
then
	命令
elif 条件2
then
	命令
elif 条件3
then 
	命令
...
else
	命令n
fi
```



# shell内置命令：test

介绍

> shell中的test命令用于检测某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。功能与[]一样

## 整数比较语法

```shell
if test 数字1 options 数字2
then
	命令
fi
```

options选项如下

| 参数 | 说明           |
| ---- | -------------- |
| -eq  | 等于则为真     |
| -ne  | 不等于则为真   |
| -gt  | 大于则为真     |
| -ge  | 大于等于则为真 |
| -lt  | 小于则为真     |
| -le  | 小于等于则为真 |



## 字符串比较语法

```shell
test 字符串1 options 字符串2
```

options选项如下

| 参数  | 说明                                      |
| ----- | ----------------------------------------- |
| =或== | 等于返回0代表成功，否正返回1代表失败      |
| !=    | 不等于                                    |
| \\<   | 小于                                      |
| \\>   | 大于                                      |
| -n    | 字符串的长度不为零则为真   test -n 字符串 |
| -z    | 字符串的长度为零则为真     test -z 字符串 |



## 对文件比较语法

```shell
test [options] 文件路径
```

options选项如下

| 参数        | 说明                                 |
| ----------- | ------------------------------------ |
| `-e 文件名` | 如果文件存在则为真                   |
| `-r 文件名` | 如果文件存在且可读则为真             |
| `-w 文件名` | 如果文件存在且可写则为真             |
| `-x 文件名` | 如果文件存在且可执行则为真           |
| `-s 文件名` | 如果文件存在且至少有一个字符则为真   |
| `-d 文件名` | 如果文件存在且为目录则为真           |
| `-f 文件名` | 如果文件存在且为普通文件则为真       |
| -c 文件名   | 如果文件存在且为字符型特殊文件则为真 |
| -b 文件名   | 如果文件存在且为块特殊文件则为真     |



# 流程控制语句：case

介绍

> case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，就执行相应的命令；当分支较多，并且判断条件比较简单时，使用case in 语句就比较方便。支持简单的正则表达式

语法

```shell
case 值 in
匹配模式1)
	命令
	;;
匹配模式2)
	命令
	;;
...
*)		//上面的都不匹配就执行这个下面的命令
	命令
	;;
esac

每一个匹配模式必须以右括号结束； `值`可以为变量或者常量；匹配发现`值`符合某一个`匹配模式`后，执行该模式下的所有命令，直到`;;`结束。
`值`将检测每一个匹配模式，一旦匹配，则执行完匹配后的相应命令后不再继续匹配其他模式。如果无一匹配模式，使用星号`*`捕获该值，再执行`*`下的命令
```

简单正则表达式支持如下通配符

| 通配符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| *      | 表示任意字符串                                               |
| [abc]  | 表示a、b、c三个字符中的任意一个                              |
| [m-n]  | 表示从m到n的任意一个字符。比如[0-9 a-z A-Z]                  |
| \|     | 表示多重选择，类似逻辑或，比如abc\|xyz 表示匹配字符串“abc”或者“xyz” |



# 流程控制语句：while

多行语法

```shell
while 条件
do
	//循环体
	命令
	...
	continue;   //结束当前这一次循环，进入到下一次循环
	break;    //跳出当前循环
done
```

单行语法

```shell
while 条件；do 命令； done;
```

死循环

```shell
死循环一
while :
do
	//循环体
	命令
done 

死循环二
while true:
do
	//循环体
	命令
done 
```



# 流程控制语句：until

介绍

> until循环与while循环再处理方式上刚好相反，循环条件为false会一直循环，条件为true停止循环。其余语法上面和while一致

语法

```shell
until 条件      //如果条件返回值为1（代表false），则继续执行循环体内的语句，否正跳出循环
do
	//循环体
	命令
done

```



# 流程控制语句：for

## 循环方式1

多行语法

```shell
for var in item1 item2 ... itemN
do
	//循环体
	命令
done

//var是循环变量
//item1 item2 ... itemN是循环的范围
```

单行写法

```shell
for var in item1 item2 ... itemN; do 命令1 ...; done;
```



## 循环方式2

多行语法

```shell
for var in {start..end}
do
	//循环体
done

//start：循环范围的起始值，必须是整数
//end：循环范围的结束值，必须是整数
//..是固定写法
```

单行写法

```shell
for var in {start..end}; do 循环体; done;
```

## 循环方式3

多行语法

```shell
for ((i=start;i<=end;i++))
do
	//循环体
done
```

单行写法

```shell
for((i=start;i<=end;i++)); do 循环体; done;
```



# 流程控制语句：select

介绍

> select in 循环用来增强交互性，它可以显示带有编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能，select in 是shell独有的一种循环，非常适合终端这样的交互场景。

语法

```shell
select var in menu1 menu2 ...
do
	//循环体
done

//注意：select是死循环，输入空值，或者输入的值无效，都不会结束循环，只有遇到break语句，获取ctrl+d才能结束循环
//执行命令过程中：终端会输出  `#?` 代表可以输入选择的菜单编号
```



# shell函数：系统函数

函数介绍

> shell编程和其他编程语言一样，函数是由若干条shell命令组成的语句块，实现shell脚本代码重用和模块化编程

## basename系统函数

介绍

> basename函数用于获取文件名的函数，根据给出的文件路径截取出文件名

语法

```shell
basename [string / pathname] [suffix]
//根据指定的字符串或者路径进行截取文件名，比如：根据路径“/one/two/a.txt”，可以截取出a.txt文件
//suffix：用于截取的时候去掉指定的后缀名
```



## dirname系统函数

介绍

> 从指定的文件绝对路径，去除文件名，返回剩下的前缀目录路径

语法

```shell
dirname 文件绝对路径
```



# shell函数：自定义函数

## 无参函数

语法

```shell
//定义函数
[function] funname ()
{
    命令
    [return 返回值]
}

//调用函数
funname 传递参数1  传递参数2  ...

//定义函数可以带function fun()定义，也可以直接fun()定义。
//参数返回，可以加return返回，如果不加，将以最后一条命令运行结果作为返回值，return后跟数值n(0-255)
```



## 有参函数

介绍

> 再shell中，调用函数时可以向其传递参数。再函数内部，通过`$n`的形式来获取参数的值。



# shell好用的工具：cut

介绍

> cut译为“剪切切割”，使用cut可以切割提取指定列、字符、字节的数据。是一个强大的文本处理工具，它可以将文本按列进行划分的文本处理。cut命令逐行读入文本，然后按列划分字段并提取、输出等操作。

语法

```shell
cut [options] filename
```

示例

```shell
//提取列
cut 文件或数据 -d 指定分隔符 -f 提取第几列

//提取字符
cut 文件或数据 -c 提取字符的范围

//提取字节
cut 文件或数据 -b 提取字节范围
```



options参数说明

| 参数            | 说明                                                   |
| --------------- | ------------------------------------------------------ |
| -f 提取范围     | 获取第几列                                             |
| -d 自定义分隔符 | 自定义分隔符，默认为制表符                             |
| -c 提取范围     | 以字符为单位进行分割                                   |
| -b 提取范围     | 以字节为单位进行分割。这些字节位置将忽略多字节字符边界 |
| -n              | 与“-b”选项连用，不分割多字节字符                       |

提取范围说明

| 提取范围 | 说明                                                   |
| -------- | ------------------------------------------------------ |
| n-       | 提取指定第n列/字符/字节后面所有数据                    |
| n-m      | 提取指定第n列/字符/字节到第m列/字符/字节中间的所有数据 |
| -m       | 提取指定第m列/字符/字节前面所有数据                    |
| n1,n2,…  | 提取指定枚举列的所有数据                               |



# shell好用的工具：sed

介绍

> sed(stream editor，流编辑器)是Linux下一款功能强大的非交互流式文本编辑器（vim式交互式文本编辑器），可以对文本文件的每一行数据匹配查询之后进行增、删、改、查等操作，支持按行、按字段、按正则匹配文本内容，灵活方便，特别适合于大文件的编辑
>
> sed是一种流编辑器，它一次处理一行内容，将这行放入缓存（存区空间称为：模式空间），然后才对这行进行处理，处理完后，将缓存区的内容发送到终端

## 语法

> sed \[选项参数] \[模式匹配/sed程序命令] [文件名]
>
> //模式匹配，sed会读取每一行数据到模式空间中，之后判断当前行是否符合模式匹配要求，符合要求就会执行sed程序命令，否则不会执行sed程序命令；如果不屑匹配模式，那么每一行都会执行sed程序命令

选项参数说明

| 命令 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -e   | 直接在指令列模式上进行sed动作编辑。他将告诉sed将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时才需要使用-e参数，一行命令语句可以执行多条sed命令 |
| -i   | 直接对内容进行修改，不加-i时默认只是预览，不会对文件做实际修改 |
| -f   | 后面跟保存了sed指令的文件                                    |
| -n   | 取消默认输出，sed默认会输出所有文本内容，使用-n参数后只显示处理过的行 |
| -r   | 使用扩展正则表达式，默认情况sed只识别基本正则表达式*         |

==sed程序命令功能描述==

| 命令 | 说明                                            |
| ---- | ----------------------------------------------- |
| a    | add新增，a的后面可以接字串，在下一行出现        |
| c    | chenge修改，修改匹配行的内容                    |
| d    | delete删除，删除匹配的内容                      |
| i    | insert插入，在匹配行前插入内容                  |
| p    | print打印，打印出匹配内容，通常于-n选项一起使用 |
| s    | substitute替换，替换掉匹配的内容                |
| =    | 用来打印被匹配的行的行号                        |
| n    | 读取下一行，遇到n时会自定跳入下一行             |



## 示例：在文件中添加数据

在指定行号前或后添加数据

```shell
sed '3a/ihello' 文件
//3：代表第3行
//a/i：代表在第三行的后面/前面添加内容
//hello：添加的内容
【注意】：这并不是直接修改文件，原文件时没有变得，要修改原文件需要加上-i参数 `sed -i '3a/ihello` 文件
```

在指定的内容前后添加数据

```shell
sed '/itheima/i或a hello'
```

在最后一行前后添加数据

```shell
sed '$i/ahello'
//$i/a：最后一行前面/后面添加
```



## 示例：在文件中删除数据

语法

```shell
sed '2d' 文件
//d：用于删除
//2d：删除第2行
```

删除奇数行

```shell
sed '1~2d' 文件
```

删除指定范围的多行数据

```shell
sed '1,3d' 文件
//1,3：从第1行开始到第3行结束
```

删除指定范围取反的多行数据

```shell
sed '1,3!d' 文件
//删除的是除了1到3行的其他所有数据
```

删除最后一行

```shell
sed '$d' 文件
```

删除含有指定内容的行

```shell
sed '/itheima/d' 文件   //删除含有itheima的行
```

删除匹配行到最后一行

```shell
sed '/itheima/,$d' 文件
```

删除匹配及其后面一行

```shell
sed '/itheima/,+1d' 文件
```



## 更改文件中的数据

修改某一行

```shell
sed 'nchello' 文件
//n：要修改的行
```

将文件中的某个内容替换

```shell
sed 's/itheima/hello/'     //将文件中的每行的第1个itheima替换成hello
sed 's/itheima/hello/g'     //将文件中的所有的itheima替换成hello
sed 's/itheima/hello/2'     //将文件中的每行的第2个itheima替换成hello
```

每行的末尾拼接一个数据

```shell
sed 's/$/& test/' 文件
//  /$：每行末尾
// &：拼接
```



## 同时执行多个sed命令

```shell
//方式一，每个命令之前使用-e参数
sed -e '命令1' -e '命令2' 文件

方式二，每个命令之间使用分号隔开
sed '命令1;命令2' 文件
```



## sed高级用法：缓存区数据交换

模式空间与暂存空间介绍

> 1. sed处理文件是逐行处理的，即读取一行处理一行，输出一行
> 2. sed把文件读出来每一行存放的空间叫模式空间，会在该空间对督导的内容做相应处理
> 3. 此外sed还有一个额外的空间即暂存空间，暂存空间刚开始里面只有个空行
> 4. sed可使用相应的命令从模式空间往暂存空间放入内容或从暂存空间取内容放入模式空间

缓存区sed命令

| 命令 | 含义                                                 |
| ---- | ---------------------------------------------------- |
| h    | 将模式空间里面的内容复制到暂存空间缓存区（覆盖方式） |
| H    | 将模式空间里面的内容复制到暂存空间缓存区（追加方式） |
| g    | 将暂存空间里面的内容复制到模式空间缓存区（覆盖方式） |
| G    | 将暂存空间里面的内容复制到模式空间缓存区（追加方式） |
| x    | 交换两个空间的内容                                   |



### 示例：缓存区数据交换

将第一行复制粘贴到最后一行

```shell
sed '1h;$G' 文件
```

将第一行复制粘贴到最后一行并删除第一行

```shell
sed '1{h,d};$g' 文件
```

将第一行的内容复制粘贴替换其他行内容

```shell
sed '1h;2,$g' 文件
```

将前3行数据复制粘贴到最后一行

```shell
sed '1,3h;$G' 文件
```

给所有行添加一个空行

```shell
sed 'G' 文件
```

删除所有空行

```shell
sed '/^$/d'  文件
```



# shell好用的工具：awk

介绍

> awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大，简单来说awk就是把文本逐行读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理，因为切开的部分使用awk可以定义变量，使用流程控制语句进行深度加工和分析

## 语法

```shell
awk [options] 'pattern{action}' {filenames}
//pattern：表示awk在数据中查找的内容，就是匹配模式
//action：在找到匹配内容时所执行的一系列命令
```

options选项参数说明

| 参数 | 说明                   |
| ---- | ---------------------- |
| -F   | 自定义文件拆分分隔符   |
| -V   | 赋值一个用户定义的变量 |

## awk内置变量

| 内置变量 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| ARGC     | 命令行参数个数                                               |
| ARGV     | 命令行参数排列                                               |
| ENVIRON  | 支持队列中系统环境变量的使用                                 |
| FIELNAME | awk浏览的文件名(获取当前操作文件的文件名)                    |
| FNR      | 浏览文件的记录数                                             |
| FS       | 设置输入域分隔符，等价于命令行-F选项                         |
| NF       | 浏览记录的域的个数，根据分隔符分割后的列数 （统计一共多少列） |
| NR       | 已读的记录数，也是行号 （获取显示行号）                      |
| OFS      | 输出域分隔符                                                 |
| ORS      | 输出记录分隔符                                               |
| RS       | 控制记录分隔符                                               |
| $n       | \$0变量是指整条记录，$1表示当前行的第一个域(列)，\$2表示当前行的第二个域……以此类推 |
| $NF      | 表示最后一列的信息，跟变量NF是由区别的，变量NF统计的是每行列的总数 |

## 示例

### 打印含有匹配信息的行

搜索passwd文件中有root关键字的所有行

```shell
awk '/root/'  passwd
```

### 打印匹配行中第7列数据

```shell
awk -F : '/root/{print $7}' passwd
//-F：以`:`为分隔符拆分每一个列（域）数据
```

### 打印文件每行属性信息

统计passwd文件名，每行的行号，每行的列数，对应的完整行内容

```shell
//方式一
awk -F : '{print "文件名：" FILENAME ",行号：" NR ",列数：" NF "，内容：" $0}' passwd 

//方式二
awk -F : '{printf("文件名:%s,行号:%s,列数:%s,内容:%s\n",FILENAME,NR,NF,$0)}' passwd 
// \n:换行
//%s：字符串占用，整数就是%i
```

### 打印第n行的内容

```shell
awk -F : 'NR==2{printf("%s",$0)}'  passwd
```

### 打印以什么开头的内容

```shell
awk '/^w/' passwd    //在passwd中查找以w开头的内容
```

### 打印最后一列内容

```shell
awk -F : '{print $NF}' passwd
```

### 打印倒数第二列内容

```shell
awk -F : '{print $(NF-1)}' passwd
```

### 打印第n到m行的内容

```shell
awk -F : '{if(NR>=10 && NR<=20) {print $0}}' passwd
//打印第10行到第20行的内容
```

### 多分隔符使用

```shell
awk -F [:/]       //以`:`和`/`都作为分隔符
```

### 添加开始与结束

```shell
awk 'BEGIN{print "开始..." } {print $0} END{print "结束..."}' passwd
```

### 使用循环拼接分割后的字符串

```shell
awk -F : -v str="" 'NR==1{for(i=1;i<=NF;i++) { str=str$i}} END{print str}' passwd 
//含义：打印第一行分割后拼接后的内容
//-v：定义一个变量
```



# shell好用的工具：sort

## 介绍

> sort命令在Linux中非常有用，它可以将文件进行排序，并将排序结果标准输出或重定向输出到指定文件

## 语法

```shell
sort (optinos) 文件
```

optinos选项详解

| 选项        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| -n          | number，按照数值的大小进行排序，升序排序                     |
| -r          | reverse，以相反的顺序排序，降序排序                          |
| -t 分割字符 | 设置排序时所用的分割字符，默认分隔符为空格                   |
| -kn,m       | 指定需要排序的列；指定的是一个n到m的范围，-k1,1 这就是第一列。 |
| -d          | 排序时，处理英文字母、数字以及空格字符外，忽略其他字符       |
| -f          | 排序时，将小写字母视为大写字母                               |
| -b          | 忽略每行前面出现的空格                                       |
| -o 输出文件 | 将排序后的结果存入指定的文件                                 |
| -u          | 去重                                                         |
| -m          | 将几个排序好的文件进行合并                                   |

