# mysql启动

```sh
net start mysql80(安装时的名字)
net stop mysql80
```

# mysql客户端连接

```sh
mysql [-h 127.0.0.1（IP）] [-P 3306（端口）] -u root -p
```



# SQL

## SQl通用语法

> 1. SQL语句可以单行或多行书写，以分号结尾
>
> 2. SQL语句可以使用空格/制表符缩进来增强语句的可读性
>
> 3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写
>
> 4. 注释：
>
>    ​	单行注释：--或#
>
>    ​	多行注释：/* 注释内容 */

## SQL分类

| 分类 | 全称                       | 说明                                                   |
| ---- | -------------------------- | ------------------------------------------------------ |
| DDL  | Data Definition Language   | 数据定义语言，用来定义数据库对象（数据库，表，字段）   |
| DML  | Data Manipulation Language | 数据操作语言，用来对数据库表中的数据进行增删改查       |
| DQL  | Data Query Language        | 数据查询语言，用来查询数据表中表的记录                 |
| DCL  | Data Control Language      | 数据控制语言，用来创建数据库用户、控制数据库的访问权限 |

## DDL：数据定义语言

### DDL-数据库操作

***查询：***

```mysql
show databases;			#查询所有数据库
select database();		#查询当前数据库
```

***创建：***

```mysql
create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];
[if not exists]:如果数据库不存在才创建
[default charset 字符集]：设置数据库的字符集
[collate 排序规则]：设置数据库的排序规则
```

***删除：***

```mysql
drop database [if exists] 数据库名;
[if exists]：如果数据库存在才删除
```

***使用：***

```mysql
use 数据库名;
```



### DDL-表操作

***查询***

```mysql
#查询当前数据库所有表
show tables;

#查询表结构
desc 表名;

#查询指定表的建表语句
show create table 表名;
```

***创建***

```mysql
create table 表名(
	字段1 类型 [comment 注释],
	字段2 类型 [comment 注释],
    字段3 类型 [comment 注释],
    ......
    字段n 类型 [comment 注释]
)[comment 表的注释];
```

***修改***

```mysql
#添加字段
alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];

#修改字段
1.修改数据类型
	alter table 表名 modify 字段名 新数据类型(长度);
2.修改字段名和字段类型
	alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];	
	
#修改表名
alter table 表名 rename to 新表名;
```

***删除***

```mysql
#删除字段
alter table 表名 drop 字段名;

#删除表
drop table [if exists] 表名;

#删除指定表，并重新创建该表。相当于清空表数据，只留下表结构
reuncate table 表名;

【注意】：在删除表时，表中的全部数据也会被删除。
```





***字段类型-数值类型***

| 类型    | 大小   | 有符号（signen）范围           | 无符号（unsignen）范围 | 描述           |
| ------- | ------ | ------------------------------ | ---------------------- | -------------- |
| tinyint | 1 byte | (-128,127)                     | (0.255)                | 小整数值       |
| int     | 4 byte | (-2147483648,2147483647)       | (0,4294967295)         | 大整数值       |
| float   | 4 byte |                                |                        | 单精度浮点数值 |
| double  | 8 byte |                                |                        | 双精度浮点数值 |
| decimal |        | 依赖于M（精度）和D（标度）的值 |                        | 小数值         |

> tinyint使用方式：
>
> ​	tinyint unsignen  #使用无符号范围
>
> ​	tinyint signen  #使用有符号范围
>
> 依赖于M（精度）和D（标度）的值：比如123.45，精度就是长度5，标度就是2小数点后2位
>
> double使用方法：
>
> ​	double(4,1)    #4代表总体长度，1代表小数点后几位

***字段类型-字符串类型***

| 类型    | 大小          | 描述       |
| ------- | ------------- | ---------- |
| char    | 0-255 bytes   | 定长字符串 |
| varchar | 0-65535 bytes | 变长字符串 |

> char和varchar的区别：
>
> ​	char比varchar性能高，因为varchar需要根据内容计算所占用的空间。而char却不需要，比如指定char(10)哪怕只有一个字符，char也会占用全部空间，其他9个会用空格进行补位。而char(10)如果只有一个字符就只占用一个字符空间

***字段类型-日期时间类型***

| 类型       | 格式                                  | 描述                   |
| ---------- | ------------------------------------- | ---------------------- |
| *date*     | YYYY-MM-DD（年月日）                  | 日期                   |
| *time*     | HH:MM:SS（时分秒）                    | 时间                   |
| year       | YYYY（年）                            | 年份                   |
| *datetime* | YYYY-MM-DD HH:MM:SS（年月日和时分秒） | 混合日期和时间         |
| timestamp  | YYYY-MM-DD HH:MM:SS（年月日和时分秒） | 混合日期和时间，时间戳 |



## DML：数据操作语言

### DML-添加数据

***给指定字段添加数据***

```mysql
insert into 表名(字段1,字段2,...) values (值1,值2,...)
```

***给全部字段添加数据***

```mysql
insert into 表名 values (值1,值2,...)
```

***批量添加数据***

```mysql
#给指定字段批量添加数据
insert into 表名(字段1,字段2,...) values (值1,值2,...),(值1,值2,...),(值1,值2,...);

#给全部字段批量添加数据
insert into 表名 values (值1,值2,...),(值1,值2,...),(值1,值2,...);
```

> 【注意】：
>
> ​	1. 插入数据时，指定的字段顺序需要与值得顺序一一对应
>
> ​	2. 字符串和日期型数据应该包含在单引号中
>
> ​	3. 插入得数据大小，应该在字段的规定范围内

### DML-修改数据

```mysql
updata 表名 set 字段名1=值1,字段名2=值2,... [where 条件];

【注意】：修改语句的条件如果没有，则会修改整张表的所有数据
```

### DML-删除数据

```mysql
delete from 表名 [where 条件];

【注意】：
	如果没有条件，则会删除整张表的所有数据
	delete语句不能删除某一个字段的值
```



## DQL-数据查询语言

***DQL语法（编写顺序）***

```mysql
select
	字段列表 
from 
	表名列表 
where
	条件列表
group by
	分组字段列表
having
	分组后条件列表
order by
	排序字段列表
limit
	分页参数
```

***DQL执行顺序***

```mysql
第一： from 表名
第二： where 条件
第三： group by 分组 having 条件
第四： select 字段列表
第五： order by 排序
第六： limit 分页
```



### 基本查询

***查询多个字段***

```mysql
#查询多个字段
select 字段1,字段2,... from 表名;

#查询所有字段
select * from 表名;
```

***设置别名***

```,mysql
select 字段1 [as 别名1],字段2 [as 别名2]... from 表名;
【as可以省略不写】
```

***去除重复记录***

```mysql
select distinct 字段列表 from 表名;
```

### 条件查询(where)

***语法***

```mysql
select 字段列表 from 表名 where 条件列表
```

***条件***

| 比较运算符                       | 功能                                       |
| -------------------------------- | ------------------------------------------ |
| 常规比较运算符（>,<,=,>=,<=,!=） | 大于，小于……                               |
| between…and…                     | 在某个范围之内（含最大、最小值）           |
| in(…)                            | 在in之后的列表中的值，多选一               |
| like ‘占位符’                    | 模糊匹配（_匹配当个字符，%匹配任意个字符） |
| is null/is not null              | 是null/不是null                            |

| 逻辑运算符 | 功能 |
| ---------- | ---- |
| and 或 &&  | 并且 |
| or 或 \|\| | 或者 |
| not 或 ！  | 非   |



### 聚合函数

***介绍***

```mysql
将一列数据作为一个整体，进行纵向计算
```

***常见聚合函数***

| 函数  | 功能     |
| ----- | -------- |
| count | 统计数量 |
| max   | 最大值   |
| min   | 最小值   |
| avg   | 平均值   |
| sum   | 求和     |

***语法***

```mysql
select 聚合函数(字段列表) from 表名;

【注意】：null值不参与聚合函数的计算
```

### 分组查询（group by）

***语法***

```mysql
select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];

【注意】：
	执行顺序：where > 聚合函数 > having
	分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无意义
```

***where 与 having 的区别***

```mysql
 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤
 判断条件不同：where不能对聚合函数进行判断，而having可以
```

### 排序查询（order by）

***语法***

```mysql
select 字段列表 from 表名 order by 字段1 排序方式1,字段2,排序方式2;

#排序方式
	asc：升序（默认值，可以省略不写）
	desc：降序

【注意】：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。
```

### 分页查询（limit）

***语法***

```mysql
select 字段列表 from 表名 limit 起始索引,查询记录数;

【注意】：
	1. 起始索引从0开始，起始索引=（查询页码-1）*每页显示的记录数。
	2. 分页查询是数据库的方言，不同的数据库有不同的实现方式，mysql中式limit
	3. 如果查询的是第一页数据，起始索引可以省略，直接简写成limit 10（10为要显示的记录数）
```



## DCL：数据控制语言

### 管理用户

***查询用户***

```mysql
#用户信息存储在mysql数据库中的user表中
use mysql;
select * from user;
```

***创建用户***

```mysql
create user '用户名'@'主机名'  identified by '密码';
【主机名可以使用%通配，表示任意主机】
```

***修改用户密码***

```mysql
alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';
【mysql_native_password 密码的加密方式】
```

***删除用户***

```mysql
drop user '用户名'@'主机名';
```

### 权限控制

***常用权限***

| 权限               | 说明               |
| ------------------ | ------------------ |
| all,all privileges | 所有权限           |
| select             | 查询数据           |
| insert             | 插入数据           |
| update             | 修改数据           |
| delete             | 删除数据           |
| alter              | 修改表             |
| drop               | 删除数据库/表/视图 |
| create             | 创建数据库/表      |

***查询权限***

```mysql
show grants for '用户名'@'主机名';
```

***授予权限***

```mysql
grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';

【注意】：
	1. 多个权限之间，使用逗号分隔
	2. 授权时，数据库名和表名都可以使用 * 进行统配，* 代表所有
```

***撤销权限***

```mysql
revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';
```



# 函数

> 函数 是指一段可以直接被另一段程序调用的程序或代码

## 字符串函数

***常见字符串函数***

| 函数                     | 功能                                                         |
| ------------------------ | ------------------------------------------------------------ |
| concat(s1,s2,…sn)        | 字符串拼接，将s1,s2,…sn拼接为一个字符串                      |
| lower(str)               | 将字符串str全部转换为小写                                    |
| upper(str)               | 将字符串str全部转换为大写                                    |
| lpad(str,n,pad)          | 左填充，用字符串pad对字符串str的左边进行填充，达到str字符串长度为n |
| rpad(str,n,pad)          | 右填充，用字符串pad对字符串str的右边进行填充，达到str字符串长度为n |
| trim(str)                | 去掉字符串str开头和结尾的空格                                |
| substring(str,start,len) | 从start位置起截取字符串str，截取len个字符，（start从1开始）  |

```mysql
select 函数(参数);
```



## 数值函数

***常见的数值函数***

| 函数       | 功能                         |
| ---------- | ---------------------------- |
| ceil(x)    | 向上取整                     |
| floor(x)   | 向下取整                     |
| mod(x,y)   | 返回x/y的模（余数）          |
| rand()     | 返回0~1之间的随机数          |
| round(x,y) | 求x得四舍五入值，保留y位小数 |



## 日期函数

***常见的日期函数***

| 函数                              | 功能                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| curdate()                         | 返回当前日期                                                 |
| curtime()                         | 返回当前时间                                                 |
| now()                             | 返回当前日期和时间                                           |
| year(date)                        | 获取指定date的年份                                           |
| month(date)                       | 获取指定date的月份                                           |
| day(date)                         | 获取指定date的日期                                           |
| date_add(date,interval expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值<br>例：date_add(now(),interval 60 day)。<br>以上例子表示：当前时间加上60天后 |
| datediff(date1,date2)             | 返回起始时间date1和结束时间date2之间的天数                   |



## 流程函数

***常用流程函数***

| 函数                                                   | 功能                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| if(value,t,f)                                          | 如果value为true,则返回t,<br>否则返回f                        |
| ifnull(value1,value2)                                  | 如果value1不为空，<br>则返回value1，否则返回value2           |
| case when [val1] then [res1] …else [default] end       | 如果var1为true,<br>则返回res1,…否则<br>返回default默认值     |
| case [expr] when [val1] then[res1] …else [default] end | 如果expr的值等于var1，<br>则返回res1，…否则<br>返回default默认值 |





# 约束

***介绍***

> 1. 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据
> 2. 目的：保证数据库中数据的正确、有效性和完整性

***约束分类***

| 约束                         | 描述                                                     | 关键字      |
| ---------------------------- | -------------------------------------------------------- | ----------- |
| 非空约束                     | 限制该字段的数据不能为null                               | not null    |
| 唯一约束                     | 保证该字段的所有数据都是唯一的、不重复的                 | unique      |
| 主键约束                     | 主键是一行数据的唯一标识，要求非空不重复                 | primary key |
| 默认约束                     | 保存数据时，如果未指定该字段的值，采用默认值             | default     |
| 检测约束<br>（8.0.16版本后） | 保证字段值满足某一个条件                                 | check       |
| 外键约束                     | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | foreign key |

> auto_increment  : 自动增长，一把和主键一起使用

【注意】：约束是作用在表中字段上的，可以在创建表/修改表的时候添加约束

## 外键约束

***添加外键***

```mysql
#创建表的时候添加外键
create table 表名(
	[constraint] [外键名称] foreign key (外键字段名) references 主表(主表字段名)
);

#给已有的表的字段添加外键
alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表字段名)
```

***删除外键***

```mysql
alter table 表名 drop foreign key 外键名称
```

***外键约束的删除和更新行为***

| 行为        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| no action   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有,<br>则不允许删除/更新，（与restrict一致） |
| restrict    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有,<br>则不允许删除/更新，（与no action一致） |
| cascade     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有,<br>则也删除/更新外键在子表中的记录，（如果删除会删除子表中关联外键的整行） |
| set null    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有,<br>则设置子表中该外键值为null（这要求该外键值允许取null） |
| set default | 父表有变更时，子表将外键列设置成一个默认的值（mysql默认引擎innodb中不支持） |

```mysql
#添加外键约束行为。也可以在创建表的时候添加
alter table 表名 add constraint 外键名 foreign key (外键字段名) references 父表名 (父表字段名) on update 行为 on delete 行为

# on update 行为 ：父表外键关联的更新行为。默认是（no action/restrict）
# on delete 行为 ：父表外键关联的删除行为。默认是（no action/restrict）

```



# 多表查询

## 多表关系

***概述***

> 在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种关系，基本分为三种：
>
> 1. 一对多（多对一）
> 2. 多对多
> 3. 一对一

***一对多（多对一）***

> 案例：部门 与 员工 的关系
>
> 关系：一个部门对应多个员工，一个员工对应一个部门
>
> 实现：在多的一方建立外键，指向一的一方的主键



***多对多***

> 案例：学生 与 课程 之间的关系
>
> 关系：一个学生可以选择多门课程，一门课程也可以供多个学生选择
>
> 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方的主键



***一对一***

> 案例：用户 与 用户详情之间的关系
>
> 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提示操作效率
>
> 实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的（unique）



## 多表查询概述

> 概述：指从多张表中查询数据。
>
> 笛卡尔积：笛卡尔积是指在数学中，两个集合A集合与B集合的所有组合情况。（在多表查询时，需要消除无效的笛卡尔积）

***多表查询的分类***

> 连接查询：
>
> ​	内连接：相当于查询A、B交集部分数据
>
> ​	外连接：
>
> ​		左外连接：查询左表所有数据，移机两张表交集部分数据
>
> ​		右外连接：查询右表所有数据，移机两张表交集部分数据
>
> ​	自连接：当前表与自身的连接查询，自连接必须使用表别名
>
> 子查询



## 连接查询-内连接

> 内连接查询的是两张表交集部分

***隐式内连接查询语法***

```mysql
select 字段列表 from 表1,表2 where 条件;
```

***显式内连接查询语法***

```mysql
select 字段列表 from 表1 [inner] join 表2 on 连接条件;
```



## 连接查询-外连接

***左外连接查询语法***

```mysql
select 字段列表 from 表1 left [outer] join 表2 on 条件
#查询表1（左表）的所有数据，包含表1和表2的交集部分的数据
```

***右外连接查询语法***

```mysql
select 字段列表 from 表1 right [outer] join 表2 on 条件
#查询表2（右表）的所有数据，包含表1和表2的交集部分的数据
```



## 连接查询-自连接

***自连接查询语法***

```mysql
select 字段列表 from 表A 别名A join 表A 别名B on 条件;
#自连接查询，可以是内连接查询，也可以是外连接查询
#自连接查询相当于将一张表看作两张来查询
```



## 联合查询-union，union all

> 联合查询，就是把多次查询的结果合并起来，形成一个新的查询结果集

***语法***

```mysql
select 字段列表 from 表A ...
union[all]
select 字段列表 from 表B ...;

【注意】：
	1. 联合查询的多张表的`列数和字段类型`必须保持一致
	2. union all 会将全部数据合并在一起，union会对合并之后的数据去重
	
#例：将薪资小于2万的员工，和 年龄大于35的员工全部查询出来
	select name from emp where age<35unionselect name from emp where salay<30000;

```



## 子查询

> 概念：sql语句中嵌套select语句，称为嵌套查询，又称子查询

***语法***

```mysql
select 字段列表 from 表名 where 字段 = (select 字段列表 from 表名);
#子查询外部的语句可以是 insert/update/delete/select 的任意一个
```

***子查询分类***

> 根据子查询结果不同，可分为：
>
> ​	标量子查询（子查询结果为单个值）
>
> ​	列子查询（子查询结果为一列）
>
> ​	行子查询（子查询结果为一行）
>
> ​	表子查询（子查询结果为多行多列）
>
> 根据子查询位置，分为：where之后、from之后、select之后。

***标量子查询***

> 子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种查询称为`标量子查询`
>
> 常用操作符：> < = >= <= != 
>
> 
>
> \#例： 查询“销售部”的所有员工信息
>
> select * from emp where demp_id = (select id from demp where demp.name = '销售部');





***列子查询***

> 子查询返回的结果是一列（可以是多行），这种子查询称为`列子查询`
>
> 常用操作符：in、not in 、any、some、all
>
> | 操作符 | 描述                                   |
> | ------ | -------------------------------------- |
> | in     | 在指定的集合范围之内，多选一           |
> | not in | 不在指定的集合范围之内                 |
> | any    | 子查询返回列表中，有任意一个满足即可   |
> | some   | 与any等同。使用some的地方都可以使用any |
> | all    | 子查询返回列表的所有值都必须满足       |
>
> 
>
> \#例查询 销售部 和 市场部 的所有员工信息
>
> select * from emp where demp_id in(select id from demp where name='销售部' or name = '市场部');



***行子查询***

> 子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。
>
> 常用的操作符：=、!=、in、not in
>
> 
>
> \#例：查询与 西毒 工资及直属领导相同的员工信息
>
> ```
> select * from emp where (salay,managerid) = (select salay,managerid from emp where name = '西毒');
> ```

***表子查询***

> 子查询返回的结果是多行多列（返回的也类似一张表），这种子查询称为表子查询
>
> 常用操作符：in
>
> 用途：可以出现在where/from/select之后。多用于在查询语句 from 之后，将表子查询返回的结果作为一张临时表再和其他表进行联查。
>
> 
>
> \#例：查询与 小昭 和 韦一笑 工资和职位相同的员工信息
>
> ```
> select * from emp where (job,salay) in (select job,salay from emp where name='小昭' or name='韦一笑');
> ```



# 事务

## 事务简介

> 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。
>
> 默认mysql的事务是自动提交的，也就是说，当执行一条DML语句，mysql会立即隐式的提交事务。



## 事务操作

***方式一***

```mysql
#查看事务提交方式
select @@autocommit;   

#设置事务提交方式（等于0代表手动提交。等于1代表自动提交）
set @@autocommit = 0;  

#提交事务
commit;

#回滚事务
rollback;
```

***方式二***

```mysql
#开启事务
start transaction 或 begin

#提交事务
commit;

#回滚事务
rollback;
```



## 事务四大特性（ACID）

> 1. 原子性（Atomicity）：事务是不可分割的最小操作单元，要么同时成功，要么同时失败。
> 2. 一致性（Consistency）：事务完成时，必须使所有数据都保持一致状态。
> 3. 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的环境下允许。
> 4. 持久性（Durability）：事务一旦提交或回滚，它对数据库中的该表就是永久的。



## 并发事务问题

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另外一个事务还没有提交的数据                     |
| 不可重复读 | 一个事务先后读到同一条记录，但两次读取的数据不同             |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在 |



## 事务隔离级别

| 隔离级别                | 是否会出现脏读 | 是否会出现不可重复读 | 是否会出现幻读 |
| ----------------------- | -------------- | -------------------- | -------------- |
| read uncommitted        | 是             | 是                   | 是             |
| read committed          | 否             | 是                   | 是             |
| repeatable read（默认） | 否             | 否                   | 是             |
| serializable            | 否             | 否                   | 否             |

***设置/查看事务隔离级别***

```mysql
#查看事务隔离级别
select @@transaction_isolation;

#设置事务隔离级别
set [session/global] transaction isolation level [read uncommitted/read committed/repeatable read/serializable];

【注意】：事务隔离级别越高，数据越安全，但是性能越低。
```



# 进阶篇：

# 存储引擎

## mysql体系结构

> 第一层：连接层
>
> ​	最上层，是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
>
> 第二层：服务层
>
> ​	主要完成大多数的核心服务功能，如sql接口，并完成缓存的查询，sql的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等
>
> 第三层：引擎层
>
> ​	存储引擎真正的负载了mysql中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。
>
> 第四层：存储层
>
> ​	主要是讲数据存储在文件系统之上，并完成与存储引擎的交互。



## 存储引擎简介

> 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以也可被称为表类型

***在创建表时，指定存储引擎***

```mysql
create table 表名(
	字段1 字段类型
    ...
    字段n 字段类型
) engine = innodb;
```

***查看当前数据库支持的存储引擎***

```mysql
show engines;
```



## 存储引擎特点

### InnoDB

***介绍***

> InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在mysql 5.5之后，InnoDB是默认的mysql存储引擎

***特点***

> DML操作遵循ACID模型，支持`事务`
>
> `行级锁`，提高并发访问性能
>
> 支持`外键`foreign key约束，保证数据的完整性和正确性

***在磁盘中涉及的文件***

> xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间，存储该表的表结构（sdi）、数据和索引。

***逻辑存储结构***

> TableSpece：表空间。表空间包含若干个段。
>
> Segment：段。段包含若干个区。
>
> Extent：区。区包含若干个页。（一个区大小为1M）
>
> Page：页。页包含若干个行。（一个页大小为16K）
>
> Row：行。



### MyISAM

***介绍***

> MyISAM是mysql早期的默认存储引擎。

***特点***

> 不支持事务，不支持外键。
>
> 支持表锁，不支持行锁。
>
> 访问速度快。

***涉及的文件***

> xxx.sdi：存储表结构信息
>
> xxx.MYD：存储数据
>
> xxx.MYI：存储索引



### Memory

***介绍***

> Memory引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能讲这些表作为临时表或缓存使用。

***特点***

> 内存存放，访问速度块。
>
> hash索引（默认）。

***涉及的文件***

> xxx.sdi：存储表结构信息。



# linux安装mysql

## 准备工资

> 下载mysql安装包。
>
> 解压安装包。
>
> 创建mysql用户和mysql组。
>
> 开始安装。

## 1.安装

```shell
cd 解压的目录

rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm

rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm 

#这一步如果报错需要先删除旧的 mariadb-libs（yum remove mariadb-libs）
rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm 

rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm

#这一步安装失败需要先安装openssl-devel (yum install -y openssl-devel)
rpm -ivh mysql-community-devel-8.0.26-1.el7.x86_64.rpm  

rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm           
           
rpm -ivh mysql-community-server-8.0.26-1.el7.x86_64.rpm
```

## 2.启动

```sh
systemctl start mysqld
```

## 3.查看自动生成的root密码

```sh
grep "password" /var/log/mysqld.log
```

## 4.登录mysql

```mysql
mysql -u root -p 
```

## 5.修改root密码

```mysql
alter user 'root'@'localhost' identified by '1234';
```

执行上面个的修改密码sql会报错，原因是设置的密码太简单，不符合它的密码校验规则。

设置密码的规则：

```mysql
set global validate_password.policy = 0; （0代表最弱的密码规则）
set global validate_password.length = 4; （4代表密码的长度）
```



# 索引

## 索引概述

***介绍***

> 索引（index）是帮助mysql`高效获取数据`的`数据结构（有序的）`。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

***优缺点***

| 优点                                                      | 缺点                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| 提高数据检索效率，降低数据库的IO成本                      | 索引也是要占用磁盘空间的                                     |
| 通过索引列对数据进行排序，降低数据排序成本，降低cpu的小号 | 索引大大提高了查询效率，同时页降低了更新表的速度，如对表进行insert、update、delete时，效率降低 |



## 索引结构

> mysql的所有是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：
>
> | 索引结构              | 描述                                                         |
> | --------------------- | ------------------------------------------------------------ |
> | B+Tree索引            | 最常见的索引类型，大部分引擎都支持B+树索引                   |
> | Hash索引              | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
> | R-tree（空间索引）    | 空格键索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
> | Full-text（全文索引） | 是一种通过建立到排序索引，快速匹配文档的方式，类似于Lucene，Solr，ES |
>
> 

***不同的引擎支持的索引情况***

| 索引       | InnoDB        | MyISAM | Memory |
| ---------- | ------------- | ------ | ------ |
| B+Tree索引 | 支持          | 支持   | 支持   |
| Hash索引   | 不支持        | 不支持 | 支持   |
| R-tree索引 | 不支持        | 支持   | 不支持 |
| Full-text  | 5.6版本后支持 | 支持   | 不支持 |

> 平常所说的索引，如果没有特别说明，都是值B+树结构的索引。
>



### B-Tree（多路平衡查找树）

> B树：
>
> 以一颗最大度数（max-degree）为5（5阶）的b-tree为例，（每个节点最多存储4个key,5个指针）。当每个节点达到第五个key的时候，就会发生中间元素向上的裂变。
>
> 度数：指的是一个节点的子节点个数。度数为5，表示每个节点下面最多5个子节点
>
> ![1680500818482](C:\Users\rth\AppData\Local\Temp\1680500818482.png)

### 标准B+Tree

![1680500363185](C:\Users\rth\AppData\Local\Temp\1680500363185.png)

> 相对于B-Tree的区别：
>
> 1. 所有的数据都会出现在叶子节点。
> 2. 叶子节点形成一个单向链表。

### mysql中的B+Tree

> mysql所有数据结构对B+Tree进行了优化，在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问性能
>
> ![1680500741361](C:\Users\rth\AppData\Local\Temp\1680500741361.png)



### Hash

> 哈希索引就是采用一定的hash算法，讲键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。
>
> 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也成为hash碰撞），可以通过链表来解决

***特点***

> 1. hash索引只能用于对等比较（=，in），不支持范围查询（between，>，<，…）
> 2. 无法利用索引完成排序操作
> 3. 查询效率高，通常只需要一次索引就可以了（没有hash碰撞），效率通常高于B+Tree索引

***存储引擎支持***

> 在mysql中，支持hash所有的是Memory引擎；
>
> 而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的



### 思考：

为什么InnoDB存储引擎选择使用B+Tree索引结构

> 1. 相对于二叉树，层级更少，搜索效率高。
> 2. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样会导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。而在B+Tree中，只有叶子节点才能找到数据，搜索效率稳定；而且叶子节点形成了双向链表，便于范围搜索和排序。
> 3. 相对于hash索引，B+Tree支持范围匹配及排序操作。



## 索引分类

| 分类     | 含义                                                 | 特点                     | 关键字   |
| -------- | ---------------------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建，只能有一个 | primary  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个               | unique   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个               |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | fulltext |

***在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：***

| 分类     | 含义                                                       | 特点                 |
| -------- | ---------------------------------------------------------- | -------------------- |
| 聚集索引 | 将数据存储与索引放在了一块，索引的叶子节点保存了行数据     | 必须有，而且只有一个 |
| 二级索引 | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |

**聚集索引的选取规则**

> 1. 如果存在主键，主键索引就是聚集索引。
> 2. 如果不存在主键，将使用第一个唯一（unique）索引作为聚集索引。
> 3. 如果既没有主键也没有唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。



## 索引语法

***创建索引***

```mysql
#给哪张表的哪个字段创建索引。可以给多个字段创建索引。
create [unique/fulltext] index 索引名 on 表名 (字段名1,...)   

[unique/fulltext]：创建什么类型的索引，不指定就是创建常规索引
```

***查看索引***

```mysql
show index from 表名;		#查看某张表的所有

```

***删除索引***

```mysql
drop index 索引名 on 表名;		#删除某张表的某个索引
```



## SQL性能分析

### sql执行频率

> mysql客户端连接成功后，通过 show [session/global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的 insert、update、delete、select 的访问频率。

```mysql
show [session/global] status like 'Com_______';		#7个下划线占位符
```



